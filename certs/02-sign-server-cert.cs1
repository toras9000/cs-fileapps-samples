#!/usr/bin/env -S dotnet run --file 
#:package Lestaly.General@0.117.0
using System.Net;
using System.Net.NetworkInformation;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Lestaly;

var settings = new
{
    CaCertFile = ThisSource.RelativeFile("gen/ca/test-ca.crt"),
    CaKeyFile = ThisSource.RelativeFile("gen/ca/test-ca.key"),

    Subjects = new Func<X500DistinguishedName>(() =>
    {
        var builder = new X500DistinguishedNameBuilder();
        builder.AddCommonName("test-server.example");
        return builder.Build();
    }),
    AltName = new Func<X509Extension>(() =>
    {
        var builder = new SubjectAlternativeNameBuilder();
        builder.AddDnsName("test-server.example");
        builder.AddDnsName("*.test-server.example");
        builder.AddIpAddress(IPAddress.Parse("127.0.0.1"));
        var nwInterfaces = NetworkInterface.GetAllNetworkInterfaces()
            .Where(nw => nw.OperationalStatus == OperationalStatus.Up)
            .Where(nw => nw.NetworkInterfaceType != NetworkInterfaceType.Loopback && nw.NetworkInterfaceType != NetworkInterfaceType.Unknown)
            .Where(nw => nw.Supports(NetworkInterfaceComponent.IPv4) || nw.Supports(NetworkInterfaceComponent.IPv6))
            .ToArray();
        foreach (var addr in nwInterfaces.SelectMany(nw => nw.GetIPProperties().UnicastAddresses))
        {
            builder.AddIpAddress(addr.Address);
        }
        return builder.Build(critical: false);
    }),

    Algorithm = HashAlgorithmName.SHA256,
    ValidityPeriod = TimeSpan.FromDays(45),

    ServerCertFile = ThisSource.RelativeFile("gen/server/test-server.crt"),
    ServerKeyFile = ThisSource.RelativeFile("gen/server/test-server.key"),
};

return await Paved.ProceedAsync(async () =>
{
    using var signal = new SignalCancellationPeriod();

    var issuer = X509Certificate2.CreateFromPem(settings.CaCertFile.ReadAllText(), settings.CaKeyFile.ReadAllText());

    var serverKey = ECDsa.Create();
    var crtReq = new CertificateRequest(settings.Subjects(), serverKey, HashAlgorithmName.SHA256);
    crtReq.CertificateExtensions.Add(settings.AltName());
    crtReq.CertificateExtensions.Add(X509BasicConstraintsExtension.CreateForEndEntity(critical: false));
    crtReq.CertificateExtensions.Add(new X509KeyUsageExtension(keyUsages: X509KeyUsageFlags.DigitalSignature, critical: false));
    crtReq.CertificateExtensions.Add(new X509EnhancedKeyUsageExtension(enhancedKeyUsages: [new Oid("1.3.6.1.5.5.7.3.1")], critical: false));
    crtReq.CertificateExtensions.Add(new X509SubjectKeyIdentifierExtension(key: crtReq.PublicKey, critical: false));
    crtReq.CertificateExtensions.Add(X509AuthorityKeyIdentifierExtension.CreateFromCertificate(issuer, includeKeyIdentifier: true, includeIssuerAndSerial: false));

    var generator = X509SignatureGenerator.CreateForECDsa(issuer.GetECDsaPrivateKey()!);

    var crtSigned = crtReq.Create(
        issuerName: issuer.IssuerName,
        generator: generator,
        notBefore: DateTimeOffset.Now,
        notAfter: DateTimeOffset.Now.Add(TimeSpan.FromDays(45)),
        serialNumber: [1]
    );

    await settings.ServerCertFile.WithDirectoryCreate().WriteAllTextAsync(crtSigned.ExportCertificatePem());
    await settings.ServerKeyFile.WithDirectoryCreate().WriteAllTextAsync(serverKey.ExportPkcs8PrivateKeyPem());
    Console.WriteLine("Generation completed.");

});
